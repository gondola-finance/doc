(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{112:function(e,t,a){"use strict";a.d(t,"a",(function(){return m})),a.d(t,"b",(function(){return j}));var n=a(0),r=a.n(n);function b(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){b(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},b=Object.keys(e);for(n=0;n<b.length;n++)a=b[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(n=0;n<b.length;n++)a=b[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=r.a.createContext({}),d=function(e){var t=r.a.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},m=function(e){var t=d(e.components);return r.a.createElement(p.Provider,{value:t},e.children)},o={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},O=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,b=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),m=d(a),O=n,j=m["".concat(l,".").concat(O)]||m[O]||o[O]||b;return a?r.a.createElement(j,i(i({ref:t},p),{},{components:a})):r.a.createElement(j,i({ref:t},p))}));function j(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var b=a.length,l=new Array(b);l[0]=O;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,l[1]=i;for(var p=2;p<b;p++)l[p]=a[p];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,a)}O.displayName="MDXCreateElement"},86:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return l})),a.d(t,"metadata",(function(){return i})),a.d(t,"toc",(function(){return c})),a.d(t,"default",(function(){return d}));var n=a(3),r=a(7),b=(a(0),a(112)),l={},i={unversionedId:"developers/contracts/SwapUtils",id:"developers/contracts/SwapUtils",isDocsHomePage:!1,title:"SwapUtils",description:"A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities.",source:"@site/docs/developers/contracts/SwapUtils.md",sourceDirName:"developers/contracts",slug:"/developers/contracts/SwapUtils",permalink:"/doc/docs/developers/contracts/SwapUtils",editUrl:"https://github.com/gondola-finance/doc/docs/developers/contracts/SwapUtils.md",version:"current",frontMatter:{},sidebar:"developers",previous:{title:"SwapFlashLoan",permalink:"/doc/docs/developers/contracts/SwapFlashLoan"},next:{title:"TimeLock",permalink:"/doc/docs/developers/contracts/TimeLock"}},c=[{value:"Functions",id:"functions",children:[{value:"getA",id:"geta",children:[]},{value:"_getA",id:"_geta",children:[]},{value:"getAPrecise",id:"getaprecise",children:[]},{value:"_getAPrecise",id:"_getaprecise",children:[]},{value:"getDepositTimestamp",id:"getdeposittimestamp",children:[]},{value:"calculateWithdrawOneToken",id:"calculatewithdrawonetoken",children:[]},{value:"calculateWithdrawOneTokenDY",id:"calculatewithdrawonetokendy",children:[]},{value:"getYD",id:"getyd",children:[]},{value:"getD",id:"getd",children:[]},{value:"getD",id:"getd-1",children:[]},{value:"_xp",id:"_xp",children:[]},{value:"_xp",id:"_xp-1",children:[]},{value:"_xp",id:"_xp-2",children:[]},{value:"getVirtualPrice",id:"getvirtualprice",children:[]},{value:"getY",id:"gety",children:[]},{value:"calculateSwap",id:"calculateswap",children:[]},{value:"_calculateSwap",id:"_calculateswap",children:[]},{value:"calculateRemoveLiquidity",id:"calculateremoveliquidity",children:[]},{value:"_calculateRemoveLiquidity",id:"_calculateremoveliquidity",children:[]},{value:"calculateCurrentWithdrawFee",id:"calculatecurrentwithdrawfee",children:[]},{value:"calculateTokenAmount",id:"calculatetokenamount",children:[]},{value:"getAdminBalance",id:"getadminbalance",children:[]},{value:"_feePerToken",id:"_feepertoken",children:[]},{value:"swap",id:"swap",children:[]},{value:"addLiquidity",id:"addliquidity",children:[]},{value:"updateUserWithdrawFee",id:"updateuserwithdrawfee",children:[]},{value:"_updateUserWithdrawFee",id:"_updateuserwithdrawfee",children:[]},{value:"removeLiquidity",id:"removeliquidity",children:[]},{value:"removeLiquidityOneToken",id:"removeliquidityonetoken",children:[]},{value:"removeLiquidityImbalance",id:"removeliquidityimbalance",children:[]},{value:"withdrawAdminFees",id:"withdrawadminfees",children:[]},{value:"setAdminFee",id:"setadminfee",children:[]},{value:"setSwapFee",id:"setswapfee",children:[]},{value:"setDefaultWithdrawFee",id:"setdefaultwithdrawfee",children:[]},{value:"rampA",id:"rampa",children:[]},{value:"stopRampA",id:"stoprampa",children:[]}]},{value:"Events",id:"events",children:[{value:"TokenSwap",id:"tokenswap",children:[]},{value:"AddLiquidity",id:"addliquidity-1",children:[]},{value:"RemoveLiquidity",id:"removeliquidity-1",children:[]},{value:"RemoveLiquidityOne",id:"removeliquidityone",children:[]},{value:"RemoveLiquidityImbalance",id:"removeliquidityimbalance-1",children:[]},{value:"NewAdminFee",id:"newadminfee",children:[]},{value:"NewSwapFee",id:"newswapfee",children:[]},{value:"NewWithdrawFee",id:"newwithdrawfee",children:[]},{value:"RampA",id:"rampa-1",children:[]},{value:"StopRampA",id:"stoprampa-1",children:[]}]}],p={toc:c};function d(e){var t=e.components,a=Object(r.a)(e,["components"]);return Object(b.b)("wrapper",Object(n.a)({},p,a,{components:t,mdxType:"MDXLayout"}),Object(b.b)("p",null,"A library to be used within Swap.sol. Contains functions responsible for custody and AMM functionalities."),Object(b.b)("p",null,"Contracts relying on this library must initialize SwapUtils.Swap struct then use this library\nfor SwapUtils.Swap struct. Note that this library contains both functions called by users and admins.\nAdmin functions should be protected within contracts using this library."),Object(b.b)("h2",{id:"functions"},"Functions"),Object(b.b)("h3",{id:"geta"},"getA"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getA(\n    struct SwapUtils.Swap self\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"Return A, the amplification coefficient ",Object(b.b)("em",{parentName:"p"}," n ")," (n - 1)"),Object(b.b)("p",null,"See the StableSwap paper for details"),Object(b.b)("h4",{id:"parameters"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")))),Object(b.b)("h4",{id:"return-values"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"A")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"parameter")))),Object(b.b)("h3",{id:"_geta"},"_getA"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _getA(\n    struct SwapUtils.Swap self\n  ) internal returns (uint256)\n")),Object(b.b)("p",null,"Return A, the amplification coefficient ",Object(b.b)("em",{parentName:"p"}," n ")," (n - 1)"),Object(b.b)("p",null,"See the StableSwap paper for details"),Object(b.b)("h4",{id:"parameters-1"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")))),Object(b.b)("h4",{id:"return-values-1"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"A")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"parameter")))),Object(b.b)("h3",{id:"getaprecise"},"getAPrecise"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getAPrecise(\n    struct SwapUtils.Swap self\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"Return A in its raw precision"),Object(b.b)("p",null,"See the StableSwap paper for details"),Object(b.b)("h4",{id:"parameters-2"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")))),Object(b.b)("h4",{id:"return-values-2"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"A")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"parameter in its raw precision form")))),Object(b.b)("h3",{id:"_getaprecise"},"_getAPrecise"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _getAPrecise(\n    struct SwapUtils.Swap self\n  ) internal returns (uint256)\n")),Object(b.b)("p",null,"Calculates and returns A based on the ramp settings"),Object(b.b)("p",null,"See the StableSwap paper for details"),Object(b.b)("h4",{id:"parameters-3"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")))),Object(b.b)("h4",{id:"return-values-3"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"A")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"parameter in its raw precision form")))),Object(b.b)("h3",{id:"getdeposittimestamp"},"getDepositTimestamp"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getDepositTimestamp(\n    struct SwapUtils.Swap self\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"Retrieves the timestamp of last deposit made by the given address"),Object(b.b)("h4",{id:"parameters-4"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")))),Object(b.b)("h4",{id:"return-values-4"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"timestamp")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"of last deposit")))),Object(b.b)("h3",{id:"calculatewithdrawonetoken"},"calculateWithdrawOneToken"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function calculateWithdrawOneToken(\n    struct SwapUtils.Swap account,\n    address tokenAmount,\n    uint256 tokenIndex,\n    uint8 self\n  ) public returns (uint256, uint256)\n")),Object(b.b)("p",null,"Calculate the dy, the amount of selected token that user receives and\nthe fee of withdrawing in one token"),Object(b.b)("h4",{id:"parameters-5"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"account")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the address that is withdrawing")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"address"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount to withdraw in the pool's precision")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"which token will be withdrawn")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")))),Object(b.b)("h4",{id:"return-values-5"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"amount of token user will receive and the associated swap fee")))),Object(b.b)("h3",{id:"calculatewithdrawonetokendy"},"calculateWithdrawOneTokenDY"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function calculateWithdrawOneTokenDY(\n    struct SwapUtils.Swap self,\n    uint8 tokenIndex,\n    uint256 tokenAmount\n  ) internal returns (uint256, uint256)\n")),Object(b.b)("p",null,"Calculate the dy of withdrawing in one token"),Object(b.b)("h4",{id:"parameters-6"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"which token will be withdrawn")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount to withdraw in the pools precision")))),Object(b.b)("h4",{id:"return-values-6"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"d and the new y after withdrawing one token")))),Object(b.b)("h3",{id:"getyd"},"getYD"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getYD(\n    uint256 a,\n    uint8 tokenIndex,\n    uint256[] xp,\n    uint256 d\n  ) internal returns (uint256)\n")),Object(b.b)("p",null,"Calculate the price of a token in the pool with given\nprecision-adjusted balances and a particular D."),Object(b.b)("p",null,"This is accomplished via solving the invariant iteratively.\nSee the StableSwap paper and Curve.fi implementation for further details."),Object(b.b)("p",null,"x_1",Object(b.b)("strong",{parentName:"p"},"2 + x1 ",Object(b.b)("em",{parentName:"strong"}," (sum' - (A"),"n"),"n - 1) ",Object(b.b)("em",{parentName:"p"}," D / (A ")," n",Object(b.b)("strong",{parentName:"p"},"n)) = D ")," (n + 1) / (n ",Object(b.b)("strong",{parentName:"p"}," (2 ",Object(b.b)("em",{parentName:"strong"}," n) ")," prod' * A)\nx_1"),"2 + b",Object(b.b)("em",{parentName:"p"},"x_1 = c\nx_1 = (x_1**2 + c) / (2"),"x_1 + b)"),Object(b.b)("h4",{id:"parameters-7"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"a")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amplification coefficient ",Object(b.b)("em",{parentName:"td"}," n ")," (n - 1). See the StableSwap paper for details.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"Index of token we are calculating for.")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"xp")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256[]"),Object(b.b)("td",{parentName:"tr",align:"left"},"a precision-adjusted set of pool balances. Array should be")))),Object(b.b)("p",null,"the same cardinality as the pool.\n|",Object(b.b)("inlineCode",{parentName:"p"},"d")," | uint256 | the stableswap invariant"),Object(b.b)("h4",{id:"return-values-7"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"price of the token, in the same precision as in xp")))),Object(b.b)("h3",{id:"getd"},"getD"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getD(\n    uint256[] xp,\n    uint256 a\n  ) internal returns (uint256)\n")),Object(b.b)("p",null,"Get D, the StableSwap invariant, based on a set of balances and a particular A."),Object(b.b)("h4",{id:"parameters-8"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"xp")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256[]"),Object(b.b)("td",{parentName:"tr",align:"left"},"a precision-adjusted set of pool balances. Array should be the same cardinality")))),Object(b.b)("p",null,"as the pool.\n|",Object(b.b)("inlineCode",{parentName:"p"},"a")," | uint256 | the amplification coefficient ",Object(b.b)("em",{parentName:"p"}," n ")," (n - 1) in A_PRECISION.\nSee the StableSwap paper for details"),Object(b.b)("h4",{id:"return-values-8"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256[]"),Object(b.b)("td",{parentName:"tr",align:"left"},"invariant, at the precision of the pool")))),Object(b.b)("h3",{id:"getd-1"},"getD"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getD(\n    struct SwapUtils.Swap self\n  ) internal returns (uint256)\n")),Object(b.b)("p",null,"Get D, the StableSwap invariant, based on self Swap struct"),Object(b.b)("h4",{id:"parameters-9"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")))),Object(b.b)("h4",{id:"return-values-9"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"The")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"invariant, at the precision of the pool")))),Object(b.b)("h3",{id:"_xp"},"_xp"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _xp(\n    uint256[] balances,\n    uint256[] precisionMultipliers\n  ) internal returns (uint256[])\n")),Object(b.b)("p",null,"Given a set of balances and precision multipliers, return the\nprecision-adjusted balances."),Object(b.b)("h4",{id:"parameters-10"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"balances")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256[]"),Object(b.b)("td",{parentName:"tr",align:"left"},"an array of token balances, in their native precisions.")))),Object(b.b)("p",null,"These should generally correspond with pooled tokens."),Object(b.b)("p",null,"|",Object(b.b)("inlineCode",{parentName:"p"},"precisionMultipliers")," | uint256[] | an array of multipliers, corresponding to\nthe amounts in the balances array. When multiplied together they\nshould yield amounts at the pool's precision."),Object(b.b)("h4",{id:"return-values-10"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"an")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256[]"),Object(b.b)("td",{parentName:"tr",align:"left"},'array of amounts "scaled" to the pool\'s precision')))),Object(b.b)("h3",{id:"_xp-1"},"_xp"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _xp(\n    struct SwapUtils.Swap self,\n    uint256[] balances\n  ) internal returns (uint256[])\n")),Object(b.b)("p",null,"Return the precision-adjusted balances of all tokens in the pool"),Object(b.b)("h4",{id:"parameters-11"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"balances")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256[]"),Object(b.b)("td",{parentName:"tr",align:"left"},"array of balances to scale")))),Object(b.b)("h4",{id:"return-values-11"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"balances")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},'array "scaled" to the pool\'s precision, allowing')))),Object(b.b)("p",null,"them to be more easily compared."),Object(b.b)("h3",{id:"_xp-2"},"_xp"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _xp(\n    struct SwapUtils.Swap self\n  ) internal returns (uint256[])\n")),Object(b.b)("p",null,"Return the precision-adjusted balances of all tokens in the pool"),Object(b.b)("h4",{id:"parameters-12"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")))),Object(b.b)("h4",{id:"return-values-12"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},'pool balances "scaled" to the pool\'s precision, allowing')))),Object(b.b)("p",null,"them to be more easily compared."),Object(b.b)("h3",{id:"getvirtualprice"},"getVirtualPrice"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getVirtualPrice(\n    struct SwapUtils.Swap self\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"Get the virtual price, to help calculate profit"),Object(b.b)("h4",{id:"parameters-13"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")))),Object(b.b)("h4",{id:"return-values-13"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"virtual price, scaled to precision of POOL_PRECISION_DECIMALS")))),Object(b.b)("h3",{id:"gety"},"getY"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getY(\n    struct SwapUtils.Swap self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 x,\n    uint256[] xp\n  ) internal returns (uint256)\n")),Object(b.b)("p",null,"Calculate the new balances of the tokens given the indexes of the token\nthat is swapped from (FROM) and the token that is swapped to (TO).\nThis function is used as a helper function to calculate how much TO token\nthe user should receive on swap."),Object(b.b)("h4",{id:"parameters-14"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndexFrom")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"index of FROM token")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndexTo")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"index of TO token")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"x")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the new total amount of FROM token")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"xp")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256[]"),Object(b.b)("td",{parentName:"tr",align:"left"},"balances of the tokens in the pool")))),Object(b.b)("h4",{id:"return-values-14"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"amount of TO token that should remain in the pool")))),Object(b.b)("h3",{id:"calculateswap"},"calculateSwap"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function calculateSwap(\n    struct SwapUtils.Swap self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) external returns (uint256 dy)\n")),Object(b.b)("p",null,"Externally calculates a swap between two tokens."),Object(b.b)("h4",{id:"parameters-15"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndexFrom")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the token to sell")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndexTo")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the token to buy")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"dx")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the number of tokens to sell. If the token charges a fee on transfers,")))),Object(b.b)("p",null,"use the amount that gets transferred after the fee."),Object(b.b)("h4",{id:"return-values-15"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"dy")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the number of tokens the user will get")))),Object(b.b)("h3",{id:"_calculateswap"},"_calculateSwap"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _calculateSwap(\n    struct SwapUtils.Swap self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx\n  ) internal returns (uint256 dy, uint256 dyFee)\n")),Object(b.b)("p",null,"Internally calculates a swap between two tokens."),Object(b.b)("p",null,"The caller is expected to transfer the actual amounts (dx and dy)\nusing the token contracts."),Object(b.b)("h4",{id:"parameters-16"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndexFrom")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the token to sell")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndexTo")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the token to buy")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"dx")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the number of tokens to sell. If the token charges a fee on transfers,")))),Object(b.b)("p",null,"use the amount that gets transferred after the fee."),Object(b.b)("h4",{id:"return-values-16"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"dy")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the number of tokens the user will get")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"dyFee")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the associated fee")))),Object(b.b)("h3",{id:"calculateremoveliquidity"},"calculateRemoveLiquidity"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function calculateRemoveLiquidity(\n    struct SwapUtils.Swap account,\n    address amount\n  ) external returns (uint256[])\n")),Object(b.b)("p",null,"A simple method to calculate amount of each underlying\ntokens that is returned upon burning given amount of\nLP tokens"),Object(b.b)("h4",{id:"parameters-17"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"account")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the address that is removing liquidity. required for withdraw fee calculation")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"amount")),Object(b.b)("td",{parentName:"tr",align:"left"},"address"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of LP tokens that would to be burned on")))),Object(b.b)("p",null,"withdrawal"),Object(b.b)("h4",{id:"return-values-17"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"array")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"of amounts of tokens user will receive")))),Object(b.b)("h3",{id:"_calculateremoveliquidity"},"_calculateRemoveLiquidity"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _calculateRemoveLiquidity(\n  ) internal returns (uint256[])\n")),Object(b.b)("h3",{id:"calculatecurrentwithdrawfee"},"calculateCurrentWithdrawFee"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function calculateCurrentWithdrawFee(\n    struct SwapUtils.Swap user\n  ) public returns (uint256)\n")),Object(b.b)("p",null,"Calculate the fee that is applied when the given user withdraws.\nWithdraw fee decays linearly over 4 weeks."),Object(b.b)("h4",{id:"parameters-18"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"user")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"address you want to calculate withdraw fee of")))),Object(b.b)("h4",{id:"return-values-18"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"current")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"withdraw fee of the user")))),Object(b.b)("h3",{id:"calculatetokenamount"},"calculateTokenAmount"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function calculateTokenAmount(\n    struct SwapUtils.Swap self,\n    address account,\n    uint256[] amounts,\n    bool deposit\n  ) external returns (uint256)\n")),Object(b.b)("p",null,'A simple method to calculate prices from deposits or\nwithdrawals, excluding fees but including slippage. This is\nhelpful as an input into the various "min" parameters on calls\nto fight front-running'),Object(b.b)("p",null,"This shouldn't be used outside frontends for user estimates."),Object(b.b)("h4",{id:"parameters-19"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"account")),Object(b.b)("td",{parentName:"tr",align:"left"},"address"),Object(b.b)("td",{parentName:"tr",align:"left"},"address of the account depositing or withdrawing tokens")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"amounts")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256[]"),Object(b.b)("td",{parentName:"tr",align:"left"},"an array of token amounts to deposit or withdrawal,")))),Object(b.b)("p",null,"corresponding to pooledTokens. The amount should be in each\npooled token's native precision. If a token charges a fee on transfers,\nuse the amount that gets transferred after the fee.\n|",Object(b.b)("inlineCode",{parentName:"p"},"deposit")," | bool | whether this is a deposit or a withdrawal"),Object(b.b)("h4",{id:"return-values-19"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"if")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"deposit was true, total amount of lp token that will be minted and if")))),Object(b.b)("p",null,"deposit was false, total amount of lp token that will be burned"),Object(b.b)("h3",{id:"getadminbalance"},"getAdminBalance"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getAdminBalance(\n    struct SwapUtils.Swap self,\n    uint256 index\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"return accumulated amount of admin fees of the token with given index"),Object(b.b)("h4",{id:"parameters-20"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"index")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"Index of the pooled token")))),Object(b.b)("h4",{id:"return-values-20"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"admin")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"balance in the token's precision")))),Object(b.b)("h3",{id:"_feepertoken"},"_feePerToken"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _feePerToken(\n    struct SwapUtils.Swap self\n  ) internal returns (uint256)\n")),Object(b.b)("p",null,"internal helper function to calculate fee per token multiplier used in\nswap fee calculations"),Object(b.b)("h4",{id:"parameters-21"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from")))),Object(b.b)("h3",{id:"swap"},"swap"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function swap(\n    struct SwapUtils.Swap self,\n    uint8 tokenIndexFrom,\n    uint8 tokenIndexTo,\n    uint256 dx,\n    uint256 minDy\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"swap two tokens in the pool"),Object(b.b)("h4",{id:"parameters-22"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from and write to")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndexFrom")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the token the user wants to sell")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndexTo")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the token the user wants to buy")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"dx")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of tokens the user wants to sell")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"minDy")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the min amount the user would like to receive, or revert.")))),Object(b.b)("h4",{id:"return-values-21"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"amount")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"of token user received on swap")))),Object(b.b)("h3",{id:"addliquidity"},"addLiquidity"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function addLiquidity(\n    struct SwapUtils.Swap self,\n    uint256[] amounts,\n    uint256 minToMint\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"Add liquidity to the pool"),Object(b.b)("h4",{id:"parameters-23"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from and write to")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"amounts")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256[]"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amounts of each token to add, in their native precision")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"minToMint")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the minimum LP tokens adding this amount of liquidity")))),Object(b.b)("p",null,"should mint, otherwise revert. Handy for front-running mitigation\nallowed addresses. If the pool is not in the guarded launch phase, this parameter will be ignored."),Object(b.b)("h4",{id:"return-values-22"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"amount")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"of LP token user received")))),Object(b.b)("h3",{id:"updateuserwithdrawfee"},"updateUserWithdrawFee"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function updateUserWithdrawFee(\n    struct SwapUtils.Swap self,\n    address user,\n    uint256 toMint\n  ) external\n")),Object(b.b)("p",null,"Update the withdraw fee for ",Object(b.b)("inlineCode",{parentName:"p"},"user"),". If the user is currently\nnot providing liquidity in the pool, sets to default value. If not, recalculate\nthe starting withdraw fee based on the last deposit's time & amount relative\nto the new deposit."),Object(b.b)("h4",{id:"parameters-24"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from and write to")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"user")),Object(b.b)("td",{parentName:"tr",align:"left"},"address"),Object(b.b)("td",{parentName:"tr",align:"left"},"address of the user depositing tokens")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"toMint")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"amount of pool tokens to be minted")))),Object(b.b)("h3",{id:"_updateuserwithdrawfee"},"_updateUserWithdrawFee"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _updateUserWithdrawFee(\n  ) internal\n")),Object(b.b)("h3",{id:"removeliquidity"},"removeLiquidity"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function removeLiquidity(\n    struct SwapUtils.Swap self,\n    uint256 amount,\n    uint256[] minAmounts\n  ) external returns (uint256[])\n")),Object(b.b)("p",null,"Burn LP tokens to remove liquidity from the pool."),Object(b.b)("p",null,"Liquidity can always be removed, even when the pool is paused."),Object(b.b)("h4",{id:"parameters-25"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from and write to")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"amount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of LP tokens to burn")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"minAmounts")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256[]"),Object(b.b)("td",{parentName:"tr",align:"left"},"the minimum amounts of each token in the pool")))),Object(b.b)("p",null,"acceptable for this burn. Useful as a front-running mitigation"),Object(b.b)("h4",{id:"return-values-23"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"amounts")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"of tokens the user received")))),Object(b.b)("h3",{id:"removeliquidityonetoken"},"removeLiquidityOneToken"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function removeLiquidityOneToken(\n    struct SwapUtils.Swap self,\n    uint256 tokenAmount,\n    uint8 tokenIndex,\n    uint256 minAmount\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"Remove liquidity from the pool all in one token."),Object(b.b)("h4",{id:"parameters-26"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from and write to")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of the lp tokens to burn")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the index of the token you want to receive")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"minAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the minimum amount to withdraw, otherwise revert")))),Object(b.b)("h4",{id:"return-values-24"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"amount")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"chosen token that user received")))),Object(b.b)("h3",{id:"removeliquidityimbalance"},"removeLiquidityImbalance"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function removeLiquidityImbalance(\n    struct SwapUtils.Swap self,\n    uint256[] amounts,\n    uint256 maxBurnAmount\n  ) public returns (uint256)\n")),Object(b.b)("p",null,"Remove liquidity from the pool, weighted differently than the\npool's current balances."),Object(b.b)("h4",{id:"parameters-27"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to read from and write to")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"amounts")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256[]"),Object(b.b)("td",{parentName:"tr",align:"left"},"how much of each token to withdraw")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"maxBurnAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the max LP token provider is willing to pay to")))),Object(b.b)("p",null,"remove liquidity. Useful as a front-running mitigation."),Object(b.b)("h4",{id:"return-values-25"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"actual")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"amount of LP tokens burned in the withdrawal")))),Object(b.b)("h3",{id:"withdrawadminfees"},"withdrawAdminFees"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function withdrawAdminFees(\n    struct SwapUtils.Swap self,\n    address to\n  ) external\n")),Object(b.b)("p",null,"withdraw all admin fees to a given address"),Object(b.b)("h4",{id:"parameters-28"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to withdraw fees from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"to")),Object(b.b)("td",{parentName:"tr",align:"left"},"address"),Object(b.b)("td",{parentName:"tr",align:"left"},"Address to send the fees to")))),Object(b.b)("h3",{id:"setadminfee"},"setAdminFee"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function setAdminFee(\n    struct SwapUtils.Swap self,\n    uint256 newAdminFee\n  ) external\n")),Object(b.b)("p",null,"Sets the admin fee"),Object(b.b)("p",null,"adminFee cannot be higher than 100% of the swap fee"),Object(b.b)("h4",{id:"parameters-29"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to update")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"newAdminFee")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"new admin fee to be applied on future transactions")))),Object(b.b)("h3",{id:"setswapfee"},"setSwapFee"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function setSwapFee(\n    struct SwapUtils.Swap self,\n    uint256 newSwapFee\n  ) external\n")),Object(b.b)("p",null,"update the swap fee"),Object(b.b)("p",null,"fee cannot be higher than 1% of each swap"),Object(b.b)("h4",{id:"parameters-30"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to update")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"newSwapFee")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"new swap fee to be applied on future transactions")))),Object(b.b)("h3",{id:"setdefaultwithdrawfee"},"setDefaultWithdrawFee"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function setDefaultWithdrawFee(\n    struct SwapUtils.Swap self,\n    uint256 newWithdrawFee\n  ) external\n")),Object(b.b)("p",null,"update the default withdraw fee. This also affects deposits made in the past as well."),Object(b.b)("h4",{id:"parameters-31"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to update")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"newWithdrawFee")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"new withdraw fee to be applied")))),Object(b.b)("h3",{id:"rampa"},"rampA"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function rampA(\n    struct SwapUtils.Swap self,\n    uint256 futureA_,\n    uint256 futureTime_\n  ) external\n")),Object(b.b)("p",null,"Start ramping up or down A parameter towards given futureA",Object(b.b)("em",{parentName:"p"}," and futureTime"),"\nChecks if the change is too rapid, and commits the new A value only when it falls under\nthe limit range."),Object(b.b)("h4",{id:"parameters-32"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to update")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"futureA_")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the new A to ramp towards")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"futureTime_")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"timestamp when the new A should be reached")))),Object(b.b)("h3",{id:"stoprampa"},"stopRampA"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function stopRampA(\n    struct SwapUtils.Swap self\n  ) external\n")),Object(b.b)("p",null,"Stops ramping A immediately. Once this function is called, rampA()\ncannot be called for another 24 hours"),Object(b.b)("h4",{id:"parameters-33"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"self")),Object(b.b)("td",{parentName:"tr",align:"left"},"struct SwapUtils.Swap"),Object(b.b)("td",{parentName:"tr",align:"left"},"Swap struct to update")))),Object(b.b)("h2",{id:"events"},"Events"),Object(b.b)("h3",{id:"tokenswap"},"TokenSwap"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event TokenSwap(\n  )\n")),Object(b.b)("h3",{id:"addliquidity-1"},"AddLiquidity"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event AddLiquidity(\n  )\n")),Object(b.b)("h3",{id:"removeliquidity-1"},"RemoveLiquidity"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event RemoveLiquidity(\n  )\n")),Object(b.b)("h3",{id:"removeliquidityone"},"RemoveLiquidityOne"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event RemoveLiquidityOne(\n  )\n")),Object(b.b)("h3",{id:"removeliquidityimbalance-1"},"RemoveLiquidityImbalance"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event RemoveLiquidityImbalance(\n  )\n")),Object(b.b)("h3",{id:"newadminfee"},"NewAdminFee"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event NewAdminFee(\n  )\n")),Object(b.b)("h3",{id:"newswapfee"},"NewSwapFee"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event NewSwapFee(\n  )\n")),Object(b.b)("h3",{id:"newwithdrawfee"},"NewWithdrawFee"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event NewWithdrawFee(\n  )\n")),Object(b.b)("h3",{id:"rampa-1"},"RampA"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event RampA(\n  )\n")),Object(b.b)("h3",{id:"stoprampa-1"},"StopRampA"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event StopRampA(\n  )\n")))}d.isMDXComponent=!0}}]);