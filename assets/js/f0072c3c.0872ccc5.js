(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{107:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return o})),n.d(t,"toc",(function(){return i})),n.d(t,"default",(function(){return p}));var a=n(3),r=n(7),b=(n(0),n(112)),l={},o={unversionedId:"developers/contracts/VirtualSwap/Bridge",id:"developers/contracts/VirtualSwap/Bridge",isDocsHomePage:!1,title:"Bridge",description:"This contract is responsible for cross-asset swaps using the Synthetix protocol as the bridging exchange.",source:"@site/docs/developers/contracts/VirtualSwap/Bridge.md",sourceDirName:"developers/contracts/VirtualSwap",slug:"/developers/contracts/VirtualSwap/Bridge",permalink:"/doc/docs/developers/contracts/VirtualSwap/Bridge",editUrl:"https://github.com/gondola-finance/doc/docs/developers/contracts/VirtualSwap/Bridge.md",version:"current",frontMatter:{},sidebar:"developers",previous:{title:"TimeLock",permalink:"/doc/docs/developers/contracts/TimeLock"},next:{title:"Proxy",permalink:"/doc/docs/developers/contracts/VirtualSwap/Proxy"}},i=[{value:"Functions",id:"functions",children:[{value:"constructor",id:"constructor",children:[]},{value:"getProxyAddressFromTargetSynthKey",id:"getproxyaddressfromtargetsynthkey",children:[]},{value:"getPendingSwapInfo",id:"getpendingswapinfo",children:[]},{value:"_settle",id:"_settle",children:[]},{value:"withdraw",id:"withdraw",children:[]},{value:"completeToSynth",id:"completetosynth",children:[]},{value:"calcCompleteToToken",id:"calccompletetotoken",children:[]},{value:"completeToToken",id:"completetotoken",children:[]},{value:"_addToPendingSynthSwapList",id:"_addtopendingsynthswaplist",children:[]},{value:"_addToPendingSynthToTokenSwapList",id:"_addtopendingsynthtotokenswaplist",children:[]},{value:"calcTokenToSynth",id:"calctokentosynth",children:[]},{value:"tokenToSynth",id:"tokentosynth",children:[]},{value:"calcSynthToToken",id:"calcsynthtotoken",children:[]},{value:"synthToToken",id:"synthtotoken",children:[]},{value:"calcTokenToToken",id:"calctokentotoken",children:[]},{value:"tokenToToken",id:"tokentotoken",children:[]},{value:"setSynthIndex",id:"setsynthindex",children:[]},{value:"getSynthIndex",id:"getsynthindex",children:[]},{value:"getSynthAddress",id:"getsynthaddress",children:[]},{value:"getSynthKey",id:"getsynthkey",children:[]},{value:"updateExchangerCache",id:"updateexchangercache",children:[]}]},{value:"Events",id:"events",children:[{value:"SynthIndex",id:"synthindex",children:[]},{value:"TokenToSynth",id:"tokentosynth-1",children:[]},{value:"SynthToToken",id:"synthtotoken-1",children:[]},{value:"TokenToToken",id:"tokentotoken-1",children:[]},{value:"Settle",id:"settle",children:[]},{value:"Withdraw",id:"withdraw-1",children:[]}]}],c={toc:i};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(b.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(b.b)("p",null,"This contract is responsible for cross-asset swaps using the Synthetix protocol as the bridging exchange.\nThere are three types of supported cross-asset swaps, tokenToSynth, synthToToken, and tokenToToken."),Object(b.b)("p",null,"1) tokenToSynth\nSwaps a supported token in a gondola pool to any synthetic asset (e.g. tBTC -> sAAVE)."),Object(b.b)("p",null,"2) synthToToken\nSwaps any synthetic asset to a suported token in a gondola pool (e.g. sDEFI -> USDC)."),Object(b.b)("p",null,"3) tokenToToken\nSwaps a supported token in a gondola pool to one in another pool (e.g. renBTC -> DAI)."),Object(b.b)("p",null,"Due to the settlement periods of synthetic assets, the users must wait until the trades can be completed.\nUsers will receive an ERC721 token that represents pending cross-asset swap. Once the waiting period is over,\nthe trades can be settled and completed by calling the ",Object(b.b)("inlineCode",{parentName:"p"},"completeToSynth")," or the ",Object(b.b)("inlineCode",{parentName:"p"},"completeToToken")," function.\nIn the cases of pending ",Object(b.b)("inlineCode",{parentName:"p"},"synthToToken")," or ",Object(b.b)("inlineCode",{parentName:"p"},"tokenToToken")," swaps, the owners of the pending swaps can also choose\nto withdraw the bridging synthetic assets instead of completing the swap."),Object(b.b)("h2",{id:"functions"},"Functions"),Object(b.b)("h3",{id:"constructor"},"constructor"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function constructor(\n  ) public\n")),Object(b.b)("p",null,"Deploys this contract and initializes the master version of the SynthSwapper contract. The address to\nthe Synthetix protocol's Exchanger contract is also set on deployment."),Object(b.b)("h3",{id:"getproxyaddressfromtargetsynthkey"},"getProxyAddressFromTargetSynthKey"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getProxyAddressFromTargetSynthKey(\n    bytes32 synthKey\n  ) public returns (contract IERC20)\n")),Object(b.b)("p",null,"Returns the address of the proxy contract targeting the synthetic asset with the given ",Object(b.b)("inlineCode",{parentName:"p"},"synthKey"),"."),Object(b.b)("h4",{id:"parameters"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"synthKey")),Object(b.b)("td",{parentName:"tr",align:"left"},"bytes32"),Object(b.b)("td",{parentName:"tr",align:"left"},"the currency key of the synth")))),Object(b.b)("h4",{id:"return-values"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"address")),Object(b.b)("td",{parentName:"tr",align:"left"},"bytes32"),Object(b.b)("td",{parentName:"tr",align:"left"},"of the proxy contract")))),Object(b.b)("h3",{id:"getpendingswapinfo"},"getPendingSwapInfo"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getPendingSwapInfo(\n    uint256 itemId\n  ) external returns (enum Bridge.PendingSwapType swapType, uint256 secsLeft, address synth, uint256 synthBalance, address tokenTo)\n")),Object(b.b)("p",null,"Returns various information of a pending swap represented by the given ",Object(b.b)("inlineCode",{parentName:"p"},"itemId"),". Information includes\nthe type of the pending swap, the number of seconds left until it can be settled, the address and the balance\nof the synth this swap currently holds, and the address of the destination token."),Object(b.b)("h4",{id:"parameters-1"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"itemId")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"ID of the pending swap")))),Object(b.b)("h4",{id:"return-values-1"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swapType")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the type of the pending virtual swap,")))),Object(b.b)("p",null,"secsLeft number of seconds left until this swap can be settled,\nsynth address of the synth this swap uses,\nsynthBalance amount of the synth this swap holds,\ntokenTo the address of the destination token"),Object(b.b)("h3",{id:"_settle"},"_settle"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _settle(\n  ) internal\n")),Object(b.b)("h3",{id:"withdraw"},"withdraw"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function withdraw(\n    uint256 itemId,\n    uint256 amount\n  ) external\n")),Object(b.b)("p",null,"Settles and withdraws the synthetic asset without swapping it to a token in a Gondola pool. Only the owner\nof the ERC721 token of ",Object(b.b)("inlineCode",{parentName:"p"},"itemId")," can call this function. Reverts if the given ",Object(b.b)("inlineCode",{parentName:"p"},"itemId")," does not represent a\n",Object(b.b)("inlineCode",{parentName:"p"},"synthToToken")," or a ",Object(b.b)("inlineCode",{parentName:"p"},"tokenToToken")," swap."),Object(b.b)("h4",{id:"parameters-2"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"itemId")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"ID of the pending swap")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"amount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of the synth to withdraw")))),Object(b.b)("h3",{id:"completetosynth"},"completeToSynth"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function completeToSynth(\n    uint256 itemId\n  ) external\n")),Object(b.b)("p",null,"Completes the pending ",Object(b.b)("inlineCode",{parentName:"p"},"tokenToSynth")," swap by settling and withdrawing the synthetic asset.\nReverts if the given ",Object(b.b)("inlineCode",{parentName:"p"},"itemId")," does not represent a ",Object(b.b)("inlineCode",{parentName:"p"},"tokenToSynth")," swap."),Object(b.b)("h4",{id:"parameters-3"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"itemId")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"ERC721 token ID representing a pending ",Object(b.b)("inlineCode",{parentName:"td"},"tokenToSynth")," swap")))),Object(b.b)("h3",{id:"calccompletetotoken"},"calcCompleteToToken"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function calcCompleteToToken(\n    uint256 itemId,\n    uint256 swapAmount\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"Calculates the expected amount of the token to receive on calling ",Object(b.b)("inlineCode",{parentName:"p"},"completeToToken()")," with\nthe given ",Object(b.b)("inlineCode",{parentName:"p"},"swapAmount"),"."),Object(b.b)("h4",{id:"parameters-4"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"itemId")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"ERC721 token ID representing a pending ",Object(b.b)("inlineCode",{parentName:"td"},"SynthToToken")," or ",Object(b.b)("inlineCode",{parentName:"td"},"TokenToToken")," swap")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swapAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of bridging synth to swap from")))),Object(b.b)("h4",{id:"return-values-2"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"expected")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"amount of the token the user will receive")))),Object(b.b)("h3",{id:"completetotoken"},"completeToToken"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function completeToToken(\n    uint256 itemId,\n    uint256 swapAmount,\n    uint256 minAmount,\n    uint256 deadline\n  ) external\n")),Object(b.b)("p",null,"Completes the pending ",Object(b.b)("inlineCode",{parentName:"p"},"SynthToToken")," or ",Object(b.b)("inlineCode",{parentName:"p"},"TokenToToken")," swap by settling the bridging synth and swapping\nit to the desired token. Only the owners of the pending swaps can call this function."),Object(b.b)("h4",{id:"parameters-5"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"itemId")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"ERC721 token ID representing a pending ",Object(b.b)("inlineCode",{parentName:"td"},"SynthToToken")," or ",Object(b.b)("inlineCode",{parentName:"td"},"TokenToToken")," swap")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swapAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of bridging synth to swap from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"minAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the minimum amount of the token to receive - reverts if this amount is not reached")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"deadline")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the timestamp representing the deadline for this transaction - reverts if deadline is not met")))),Object(b.b)("h3",{id:"_addtopendingsynthswaplist"},"_addToPendingSynthSwapList"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _addToPendingSynthSwapList(\n  ) internal returns (uint256)\n")),Object(b.b)("h3",{id:"_addtopendingsynthtotokenswaplist"},"_addToPendingSynthToTokenSwapList"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function _addToPendingSynthToTokenSwapList(\n  ) internal returns (uint256)\n")),Object(b.b)("h3",{id:"calctokentosynth"},"calcTokenToSynth"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function calcTokenToSynth(\n    contract ISwap swap,\n    uint8 tokenFromIndex,\n    bytes32 synthOutKey,\n    uint256 tokenInAmount\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"Calculates the expected amount of the desired synthetic asset the caller will receive after completing\na ",Object(b.b)("inlineCode",{parentName:"p"},"TokenToSynth")," swap with the given parameters. This calculation does not consider the settlement periods."),Object(b.b)("h4",{id:"parameters-6"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swap")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the address of a Gondola pool to use to swap the given token to a bridging synth")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenFromIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the index of the token to swap from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"synthOutKey")),Object(b.b)("td",{parentName:"tr",align:"left"},"bytes32"),Object(b.b)("td",{parentName:"tr",align:"left"},"the currency key of the desired synthetic asset")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenInAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of the token to swap form")))),Object(b.b)("h4",{id:"return-values-3"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"expected amount of the desired synth")))),Object(b.b)("h3",{id:"tokentosynth"},"tokenToSynth"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function tokenToSynth(\n    contract ISwap swap,\n    uint8 tokenFromIndex,\n    bytes32 synthOutKey,\n    uint256 tokenInAmount,\n    uint256 minAmount\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"Initiates a cross-asset swap from a token supported in the ",Object(b.b)("inlineCode",{parentName:"p"},"swap")," pool to any synthetic asset.\nThe caller will receive an ERC721 token representing their ownership of the pending cross-asset swap."),Object(b.b)("h4",{id:"parameters-7"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swap")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the address of a Gondola pool to use to swap the given token to a bridging synth")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenFromIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the index of the token to swap from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"synthOutKey")),Object(b.b)("td",{parentName:"tr",align:"left"},"bytes32"),Object(b.b)("td",{parentName:"tr",align:"left"},"the currency key of the desired synthetic asset")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenInAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of the token to swap form")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"minAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of the token to swap form")))),Object(b.b)("h4",{id:"return-values-4"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"ID")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"of the ERC721 token sent to the caller")))),Object(b.b)("h3",{id:"calcsynthtotoken"},"calcSynthToToken"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function calcSynthToToken(\n    contract ISwap swap,\n    bytes32 synthInKey,\n    uint8 tokenToIndex,\n    uint256 synthInAmount\n  ) external returns (uint256, uint256)\n")),Object(b.b)("p",null,"Calculates the expected amount of the desired token the caller will receive after completing\na ",Object(b.b)("inlineCode",{parentName:"p"},"SynthToToken")," swap with the given parameters. This calculation does not consider the settlement periods or\nany potential changes of the ",Object(b.b)("inlineCode",{parentName:"p"},"swap")," pool composition."),Object(b.b)("h4",{id:"parameters-8"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swap")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the address of a Gondola pool to use to swap the given token to a bridging synth")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"synthInKey")),Object(b.b)("td",{parentName:"tr",align:"left"},"bytes32"),Object(b.b)("td",{parentName:"tr",align:"left"},"the currency key of the synth to swap from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenToIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the index of the token to swap to")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"synthInAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of the synth to swap form")))),Object(b.b)("h4",{id:"return-values-5"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"expected amount of the bridging synth and the expected amount of the desired token")))),Object(b.b)("h3",{id:"synthtotoken"},"synthToToken"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function synthToToken(\n    contract ISwap swap,\n    bytes32 synthInKey,\n    uint8 tokenToIndex,\n    uint256 synthInAmount,\n    uint256 minMediumSynthAmount\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"Initiates a cross-asset swap from a synthetic asset to a supported token. The caller will receive\nan ERC721 token representing their ownership of the pending cross-asset swap."),Object(b.b)("h4",{id:"parameters-9"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swap")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the address of a Gondola pool to use to swap the given token to a bridging synth")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"synthInKey")),Object(b.b)("td",{parentName:"tr",align:"left"},"bytes32"),Object(b.b)("td",{parentName:"tr",align:"left"},"the currency key of the synth to swap from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenToIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the index of the token to swap to")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"synthInAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of the synth to swap form")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"minMediumSynthAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the minimum amount of the bridging synth at pre-settlement stage")))),Object(b.b)("h4",{id:"return-values-6"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"ID of the ERC721 token sent to the caller")))),Object(b.b)("h3",{id:"calctokentotoken"},"calcTokenToToken"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function calcTokenToToken(\n    contract ISwap[2] swaps,\n    uint8 tokenFromIndex,\n    uint8 tokenToIndex,\n    uint256 tokenFromAmount\n  ) external returns (uint256, uint256)\n")),Object(b.b)("p",null,"Calculates the expected amount of the desired token the caller will receive after completing\na ",Object(b.b)("inlineCode",{parentName:"p"},"TokenToToken")," swap with the given parameters. This calculation does not consider the settlement periods or\nany potential changes of the pool compositions."),Object(b.b)("h4",{id:"parameters-10"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swaps")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap","[2]"),Object(b.b)("td",{parentName:"tr",align:"left"},"the addresses of the two Gondola pools used to do the cross-asset swap")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenFromIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the index of the token in the first ",Object(b.b)("inlineCode",{parentName:"td"},"swaps")," pool to swap from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenToIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the index of the token in the second ",Object(b.b)("inlineCode",{parentName:"td"},"swaps")," pool to swap to")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenFromAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of the token to swap from")))),Object(b.b)("h4",{id:"return-values-7"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap","[2]"),Object(b.b)("td",{parentName:"tr",align:"left"},"expected amount of bridging synth at pre-settlement stage and the expected amount of the desired")))),Object(b.b)("p",null,"token"),Object(b.b)("h3",{id:"tokentotoken"},"tokenToToken"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function tokenToToken(\n    contract ISwap[2] swaps,\n    uint8 tokenFromIndex,\n    uint8 tokenToIndex,\n    uint256 tokenFromAmount,\n    uint256 minMediumSynthAmount\n  ) external returns (uint256)\n")),Object(b.b)("p",null,"Initiates a cross-asset swap from a token in one Gondola pool to one in another. The caller will receive\nan ERC721 token representing their ownership of the pending cross-asset swap."),Object(b.b)("h4",{id:"parameters-11"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swaps")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap","[2]"),Object(b.b)("td",{parentName:"tr",align:"left"},"the addresses of the two Gondola pools used to do the cross-asset swap")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenFromIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the index of the token in the first ",Object(b.b)("inlineCode",{parentName:"td"},"swaps")," pool to swap from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenToIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the index of the token in the second ",Object(b.b)("inlineCode",{parentName:"td"},"swaps")," pool to swap to")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"tokenFromAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the amount of the token to swap from")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"minMediumSynthAmount")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint256"),Object(b.b)("td",{parentName:"tr",align:"left"},"the minimum amount of the bridging synth at pre-settlement stage")))),Object(b.b)("h4",{id:"return-values-8"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap","[2]"),Object(b.b)("td",{parentName:"tr",align:"left"},"ID of the ERC721 token sent to the caller")))),Object(b.b)("h3",{id:"setsynthindex"},"setSynthIndex"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function setSynthIndex(\n    contract ISwap swap,\n    uint8 synthIndex,\n    bytes32 currencyKey\n  ) external\n")),Object(b.b)("p",null,"Registers the index and the address of the supported synth from the given ",Object(b.b)("inlineCode",{parentName:"p"},"swap")," pool. The matching currency key must\nbe supplied for a successful registration."),Object(b.b)("h4",{id:"parameters-12"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swap")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the address of the pool that contains the synth")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"synthIndex")),Object(b.b)("td",{parentName:"tr",align:"left"},"uint8"),Object(b.b)("td",{parentName:"tr",align:"left"},"the index of the supported synth in the given ",Object(b.b)("inlineCode",{parentName:"td"},"swap")," pool")),Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"currencyKey")),Object(b.b)("td",{parentName:"tr",align:"left"},"bytes32"),Object(b.b)("td",{parentName:"tr",align:"left"},"the currency key of the synth in bytes32 form")))),Object(b.b)("h3",{id:"getsynthindex"},"getSynthIndex"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getSynthIndex(\n    contract ISwap swap\n  ) public returns (uint8)\n")),Object(b.b)("p",null,"Returns the index of the supported synth in the given ",Object(b.b)("inlineCode",{parentName:"p"},"swap")," pool. Reverts if the ",Object(b.b)("inlineCode",{parentName:"p"},"swap")," pool\nis not registered."),Object(b.b)("h4",{id:"parameters-13"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swap")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the address of the pool that contains the synth")))),Object(b.b)("h4",{id:"return-values-9"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"index of the supported synth")))),Object(b.b)("h3",{id:"getsynthaddress"},"getSynthAddress"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getSynthAddress(\n    contract ISwap swap\n  ) public returns (address)\n")),Object(b.b)("p",null,"Returns the address of the supported synth in the given ",Object(b.b)("inlineCode",{parentName:"p"},"swap")," pool. Reverts if the ",Object(b.b)("inlineCode",{parentName:"p"},"swap")," pool\nis not registered."),Object(b.b)("h4",{id:"parameters-14"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swap")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the address of the pool that contains the synth")))),Object(b.b)("h4",{id:"return-values-10"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"address of the supported synth")))),Object(b.b)("h3",{id:"getsynthkey"},"getSynthKey"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function getSynthKey(\n    contract ISwap swap\n  ) public returns (bytes32)\n")),Object(b.b)("p",null,"Returns the currency key of the supported synth in the given ",Object(b.b)("inlineCode",{parentName:"p"},"swap")," pool. Reverts if the ",Object(b.b)("inlineCode",{parentName:"p"},"swap")," pool\nis not registered."),Object(b.b)("h4",{id:"parameters-15"},"Parameters:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"swap")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"the address of the pool that contains the synth")))),Object(b.b)("h4",{id:"return-values-11"},"Return Values:"),Object(b.b)("table",null,Object(b.b)("thead",{parentName:"table"},Object(b.b)("tr",{parentName:"thead"},Object(b.b)("th",{parentName:"tr",align:"left"},"Name"),Object(b.b)("th",{parentName:"tr",align:"left"},"Type"),Object(b.b)("th",{parentName:"tr",align:"left"},"Description"))),Object(b.b)("tbody",{parentName:"table"},Object(b.b)("tr",{parentName:"tbody"},Object(b.b)("td",{parentName:"tr",align:"left"},Object(b.b)("inlineCode",{parentName:"td"},"the")),Object(b.b)("td",{parentName:"tr",align:"left"},"contract ISwap"),Object(b.b)("td",{parentName:"tr",align:"left"},"currency key of the supported synth")))),Object(b.b)("h3",{id:"updateexchangercache"},"updateExchangerCache"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  function updateExchangerCache(\n  ) public\n")),Object(b.b)("p",null,"Updates the stored address of the ",Object(b.b)("inlineCode",{parentName:"p"},"EXCHANGER")," contract. When the Synthetix team upgrades their protocol,\na new Exchanger contract is deployed. This function manually updates the stored address."),Object(b.b)("h2",{id:"events"},"Events"),Object(b.b)("h3",{id:"synthindex"},"SynthIndex"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event SynthIndex(\n  )\n")),Object(b.b)("h3",{id:"tokentosynth-1"},"TokenToSynth"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event TokenToSynth(\n  )\n")),Object(b.b)("h3",{id:"synthtotoken-1"},"SynthToToken"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event SynthToToken(\n  )\n")),Object(b.b)("h3",{id:"tokentotoken-1"},"TokenToToken"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event TokenToToken(\n  )\n")),Object(b.b)("h3",{id:"settle"},"Settle"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event Settle(\n  )\n")),Object(b.b)("h3",{id:"withdraw-1"},"Withdraw"),Object(b.b)("pre",null,Object(b.b)("code",{parentName:"pre",className:"language-solidity"},"  event Withdraw(\n  )\n")))}p.isMDXComponent=!0},112:function(e,t,n){"use strict";n.d(t,"a",(function(){return d})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function b(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){b(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},b=Object.keys(e);for(a=0;a<b.length;a++)n=b[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(a=0;a<b.length;a++)n=b[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),p=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,b=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),d=p(n),m=a,h=d["".concat(l,".").concat(m)]||d[m]||s[m]||b;return n?r.a.createElement(h,o(o({ref:t},c),{},{components:n})):r.a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var b=n.length,l=new Array(b);l[0]=m;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var c=2;c<b;c++)l[c]=n[c];return r.a.createElement.apply(null,l)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);